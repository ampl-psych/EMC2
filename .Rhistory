matchfun <- function(data) data$S == data$lR
trend <- make_trend(par_names = "m", cov_names = list(c("covariate1", "covariate2")), kernels = "exp_incr", ffill_na=FALSE,
phase = "pretransform")
design_base <- design(factors = list(subjects = 1, S = 1:2),
Rlevels = 1:2,
covariates = c('covariate1', 'covariate2'),
matchfun = matchfun,
trend = trend,
formula = list(m ~ lM, s ~ 1, t0 ~ 1),
contrasts = list(lM = ADmat),
model = LNR)
##mapped_pars(design_base)
p_vector <- sampled_pars(design_base, doMap = FALSE)
p_vector[1:6] <- c(-1, 1.5, log(1), log(.2), log(.2), log(.2))
covariate1 <- rnorm(n_trials*2)
covariate2 <- rnorm(n_trials*2)
# Ensure that NAs are handled correctly in trend
covariate2[c(1:5, 8)] <- NA
dat <- make_data(p_vector, design_base, n_trials = n_trials,
covariates = data.frame(covariate1 = covariate1, covariate2 = covariate2),
return_trialwise_parameters=TRUE)
attr(dat, "trialwise_parameters")
pri <- prior(design_base, type = "single")
devtools::load_all()
debug(mapper_wrapper)
plot(pri)
devtools::load_all()
plot(pri)
rm(list = ls())
devtools::load_all()
n_trials <- 50
ADmat <- cbind(d = c(-1/2, 1/2))
matchfun <- function(data) data$S == data$lR
trend <- make_trend(par_names = "m", cov_names = list(c("covariate1", "covariate2")), kernels = "exp_incr", ffill_na=FALSE,
phase = "posttransform")
design_base <- design(factors = list(subjects = 1, S = 1:2),
Rlevels = 1:2,
covariates = c('covariate1', 'covariate2'),
matchfun = matchfun,
trend = trend,
formula = list(m ~ lM, s ~ 1, t0 ~ 1),
contrasts = list(lM = ADmat),
model = LNR)
##mapped_pars(design_base)
p_vector <- sampled_pars(design_base, doMap = FALSE)
p_vector[1:6] <- c(-1, 1.5, log(1), log(.2), log(.2), log(.2))
covariate1 <- rnorm(n_trials*2)
covariate2 <- rnorm(n_trials*2)
# Ensure that NAs are handled correctly in trend
covariate2[c(1:5, 8)] <- NA
dat <- make_data(p_vector, design_base, n_trials = n_trials,
covariates = data.frame(covariate1 = covariate1, covariate2 = covariate2),
return_trialwise_parameters=TRUE)
attr(dat, "trialwise_parameters")
pri <- prior(design_base, type = "single")
devtools::load_all()
plot(pri)
devtools::test()
devtools::document()
usethis::use_import_from("stats", "ecdf")
devtools::test()
testthat::snapshot_review("trend")
devtools::test()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::check()
pkgdown::build_site()
devtools::load_all()
devtools::document()
pkgdown::build_site()
devtools::load_all()
pkgdown::build_site()
rm(list = ls())
library(EMC2)
rm(list = ls())
library(EMC2)
matchfun <- function(d) d$S == d$lR
design_LBA <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
matchfun = matchfun,
formula =list(v~lM,B~1, t0~1, sv~1, A~1),
constants=c(sv=log(1)),
model = LBA)
prior_LBA <- prior(design_LBA, type = "single",
pmean = c(1.3, .7, log(.8), log(.2), log(.3)),
psd = c(.2, .1, .1, .05, .05))
plot(prior_LBA, N = 1e3)
load("SBC_data/SBC_LBA_single.RData")
plot_sbc_hist(SBC_LBA_single, bins = 10)
plot_sbc_ecdf(SBC_LBA_single)
load("SBC_data/SBC_DDM_single.RData")
plot_sbc_ecdf(SBC_DDM_single)
n_subjects <- 30
#
matchfun <- function(d) d$S == d$lR
design_LBA <- design(factors=list(subjects=1:n_subjects,S=c("left", "right")),
Rlevels = c("left", "right"),
matchfun = matchfun,
formula =list(v~lM,B~1, t0~1, sv~1, A~1),
constants=c(sv=log(1)),
model = LBA)
prior_LBA <- prior(design_LBA, type = "diagonal-gamma",
mu_mean = c(1.3, .7, log(.8), log(.2), log(.3)),
mu_sd = c(.2, .1, .1, .05, .05),
shape = 10,
rate = c(.2, .2, .2, .1, .1))
plot(prior_LBA, selection = "alpha", N = 1e3, subject = 1)
pkgdown::build_site()
devtools::check()
install.packages("rhub")
rhub::check()
?rhubv2
n_trials <- 10000
go_rt <- exp(rnorm(n_trials, -.5, .3))
hist(go_rt)
n_trials <- 10000
go_rt <- exp(rnorm(n_trials, -.5, .3))
hist(go_rt)
ampl <- exp(rnorm(n_trials, -.75, .3))
hist(go_rt - ampl)
hist(ampl)
n_trials <- 10000
go_rt <- exp(rnorm(n_trials, -.5, .3))
hist(go_rt)
ampl <- exp(rnorm(n_trials, -1, .3))
hist(go_rt - ampl)
hist(ampl)
devtools::load_all()
devtools::load_all()
.rs.restartR()
rm(list = ls())
# devtools::install("~/Documents/2025/EMC2/")
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
library(AccumulatR)
RNGkind("L'Ecuyer-CMRG")
set.seed(1234)
load("~/Documents/2025/Stop-change-real/dat_sc_emc.RData")
dat_sc_emc$SS <- !is.infinite(dat_sc_emc$SSD)
dat_sc_emc$SS <- factor(dat_sc_emc$SS)
plot_density(dat_sc_emc, factors = c("subjects", "S"), layout = c(1,2))
table(dat_sc_emc$R, dat_sc_emc$SS, dat_sc_emc$S)
i <- 1
dat <- dat_sc_emc[dat_sc_emc$subjects==unique(dat_sc_emc$subjects)[i],c("subjects", "S", "R", "rt", "SSD", "SS")]
dat$subjects <- factor(dat$subjects)
dat$onset <- 0
dat$onset[dat$SSD != Inf] <- dat$SSD[!is.infinite(dat$SSD)]
univalent_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal", onset = 0.15) |>
add_accumulator("change2left", "lognormal", onset = 0.20) |>
add_accumulator("change2right", "lognormal", onset = 0.20) |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("C2L", "change2left") |>
add_pool("C2R", "change2right") |>
add_outcome("Left", first_of(inhibit("GO_LEFT", by = "STOP"),all_of("STOP", "C2L")),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("Right", first_of(inhibit("GO_RIGHT", by = "STOP"),all_of("STOP", "C2R")),
options = list(component = c("go_only", "go_stop"))
) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change2left", "change2right"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(univalent_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "Left" & (data$accumulator == "go_left" | data$accumulator == "change2left")] <- TRUE
out[data$S == "Right" & (data$accumulator == "go_right" | data$accumulator == "change2right")] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator %in% c("change2left", "change2right")
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$onset
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
ADmat <- cbind(d = c(1/2, -1/2))
dat$cond <- ifelse(is.infinite(dat$SSD), "GO", "STOP")
dat$cond <- factor(dat$cond)
dat$component <- ifelse(is.infinite(dat$SSD), "go_only", "go_stop")
dat$component <- factor(dat$component)
des <- design(data = dat,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
contrasts = list(lM = ADmat),
constants = c("p1_groupstop:lMd" = 0,
"t0_groupchange" = 0,
"t0_groupstop" = 0))
devtools::load_all("~/Documents/2025/EMC2/")
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
debug(ensure_native_ctx)
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
model_spec
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
debug(ensure_native_ctx)
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
debug(ensure_native_ctx)
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
emc
.rs.restartR()
rm(list = ls())
# devtools::install("~/Documents/2025/EMC2/")
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
library(AccumulatR)
RNGkind("L'Ecuyer-CMRG")
set.seed(1234)
load("~/Documents/2025/Stop-change-real/dat_sc_emc.RData")
dat_sc_emc$SS <- !is.infinite(dat_sc_emc$SSD)
dat_sc_emc$SS <- factor(dat_sc_emc$SS)
plot_density(dat_sc_emc, factors = c("subjects", "S"), layout = c(1,2))
table(dat_sc_emc$R, dat_sc_emc$SS, dat_sc_emc$S)
i <- 1
dat <- dat_sc_emc[dat_sc_emc$subjects==unique(dat_sc_emc$subjects)[i],c("subjects", "S", "R", "rt", "SSD", "SS")]
dat$subjects <- factor(dat$subjects)
dat$onset <- 0
dat$onset[dat$SSD != Inf] <- dat$SSD[!is.infinite(dat$SSD)]
univalent_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal", onset = 0.15) |>
add_accumulator("change2left", "lognormal", onset = 0.20) |>
add_accumulator("change2right", "lognormal", onset = 0.20) |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("C2L", "change2left") |>
add_pool("C2R", "change2right") |>
add_outcome("Left", first_of(inhibit("GO_LEFT", by = "STOP"),all_of("STOP", "C2L")),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("Right", first_of(inhibit("GO_RIGHT", by = "STOP"),all_of("STOP", "C2R")),
options = list(component = c("go_only", "go_stop"))
) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change2left", "change2right"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(univalent_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "Left" & (data$accumulator == "go_left" | data$accumulator == "change2left")] <- TRUE
out[data$S == "Right" & (data$accumulator == "go_right" | data$accumulator == "change2right")] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator %in% c("change2left", "change2right")
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$onset
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
ADmat <- cbind(d = c(1/2, -1/2))
dat$cond <- ifelse(is.infinite(dat$SSD), "GO", "STOP")
dat$cond <- factor(dat$cond)
dat$component <- ifelse(is.infinite(dat$SSD), "go_only", "go_stop")
dat$component <- factor(dat$component)
des <- design(data = dat,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
contrasts = list(lM = ADmat),
constants = c("p1_groupstop:lMd" = 0,
"t0_groupchange" = 0,
"t0_groupstop" = 0))
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
debug(ensure_native_ctx)
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
rm(list = ls())
# devtools::install("~/Documents/2025/EMC2/")
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
library(AccumulatR)
RNGkind("L'Ecuyer-CMRG")
set.seed(1234)
load("~/Documents/2025/Stop-change-real/dat_sc_emc.RData")
dat_sc_emc$SS <- !is.infinite(dat_sc_emc$SSD)
dat_sc_emc$SS <- factor(dat_sc_emc$SS)
plot_density(dat_sc_emc, factors = c("subjects", "S"), layout = c(1,2))
table(dat_sc_emc$R, dat_sc_emc$SS, dat_sc_emc$S)
i <- 1
dat <- dat_sc_emc[dat_sc_emc$subjects==unique(dat_sc_emc$subjects)[i],c("subjects", "S", "R", "rt", "SSD", "SS")]
dat$subjects <- factor(dat$subjects)
dat$onset <- 0
dat$onset[dat$SSD != Inf] <- dat$SSD[!is.infinite(dat$SSD)]
univalent_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal", onset = 0.15) |>
add_accumulator("change2left", "lognormal", onset = 0.20) |>
add_accumulator("change2right", "lognormal", onset = 0.20) |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("C2L", "change2left") |>
add_pool("C2R", "change2right") |>
add_outcome("Left", first_of(inhibit("GO_LEFT", by = "STOP"),all_of("STOP", "C2L")),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("Right", first_of(inhibit("GO_RIGHT", by = "STOP"),all_of("STOP", "C2R")),
options = list(component = c("go_only", "go_stop"))
) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change2left", "change2right"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(univalent_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "Left" & (data$accumulator == "go_left" | data$accumulator == "change2left")] <- TRUE
out[data$S == "Right" & (data$accumulator == "go_right" | data$accumulator == "change2right")] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator %in% c("change2left", "change2right")
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$onset
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
ADmat <- cbind(d = c(1/2, -1/2))
dat$cond <- ifelse(is.infinite(dat$SSD), "GO", "STOP")
dat$cond <- factor(dat$cond)
dat$component <- ifelse(is.infinite(dat$SSD), "go_only", "go_stop")
dat$component <- factor(dat$component)
des <- design(data = dat,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
contrasts = list(lM = ADmat),
constants = c("p1_groupstop:lMd" = 0,
"t0_groupchange" = 0,
"t0_groupstop" = 0))
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
debug(ensure_native_ctx)
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
model_spec
ctx
devtools::load_all("~/Documents/2025/EMC2/")
emc <- make_emc(dat, des, type = "single")
emc <- fit(emc, fileName = "stop_change_2nd.RData", stop_criteria = list(preburn = list(iter = 10)))
sub_emc
debug(AccumulatR_check_context)
model_spec
attr(dat, "AccumulatR_context")
model_spec
ctx <- attr(dat, "AccumulatR_context")
save(ctx, model_spec, file = "test_context.RData")
load("~/Documents/2025/EMC2/test_context.RData")
rm(list = ls())
load("~/Documents/2025/EMC2/test_context.RData")
ensure_native_ctx(ctx, model_spec)
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
credint(emc)
library(EMC2)
credint(emc)
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
credint(emc)
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
credint(emc)
exp(0.08)
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
credint(emc)
devtools::load_all()
credint(emc)
rm(list = ls())
devtools::load_all()
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
fit(emc, cores_for_chains = 1)
rm(list = ls())
devtools::load_all()
load("~/Documents/2025/EMC2/stop_change_2nd.RData")
fit(emc, cores_for_chains = 1)
log(0)
remove.packages("AccumulatR")
devtools::load_all()
library(AccumulatR)
.rs.restartR()
library(AccumulatR)
remove.packages("EMC2")
.rs.restartR()
devtools::load_all()
.rs.restartR()
devtools::install()
.rs.restartR()
rm(list = ls())
# devtools::install("~/Documents/2025/EMC2/")
# devtools::load_all("~/Documents/2025/EMC2/")
library(EMC2)
library(AccumulatR)
RNGkind("L'Ecuyer-CMRG")
set.seed(1234)
load("~/Documents/2025/Stop-change-real/dat_sc_emc.RData")
dat_sc_emc$SS <- !is.infinite(dat_sc_emc$SSD)
dat_sc_emc$SS <- factor(dat_sc_emc$SS)
plot_density(dat_sc_emc, factors = c("subjects", "S"), layout = c(1,2))
table(dat_sc_emc$R, dat_sc_emc$SS, dat_sc_emc$S)
i <- 1
dat <- dat_sc_emc[dat_sc_emc$subjects==unique(dat_sc_emc$subjects)[i],c("subjects", "S", "R", "rt", "SSD", "SS")]
dat$subjects <- factor(dat$subjects)
dat$onset <- 0
dat$onset[dat$SSD != Inf] <- dat$SSD[!is.infinite(dat$SSD)]
univalent_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal", onset = 0.15) |>
add_accumulator("change2left", "lognormal", onset = 0.20) |>
add_accumulator("change2right", "lognormal", onset = 0.20) |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("C2L", "change2left") |>
add_pool("C2R", "change2right") |>
add_outcome("Left", first_of(inhibit("GO_LEFT", by = "STOP"),all_of("STOP", "C2L")),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("Right", first_of(inhibit("GO_RIGHT", by = "STOP"),all_of("STOP", "C2R")),
options = list(component = c("go_only", "go_stop"))
) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change2left", "change2right"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(univalent_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "Left" & (data$accumulator == "go_left" | data$accumulator == "change2left")] <- TRUE
out[data$S == "Right" & (data$accumulator == "go_right" | data$accumulator == "change2right")] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator %in% c("change2left", "change2right")
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$onset
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
ADmat <- cbind(d = c(1/2, -1/2))
dat$cond <- ifelse(is.infinite(dat$SSD), "GO", "STOP")
dat$cond <- factor(dat$cond)
dat$component <- ifelse(is.infinite(dat$SSD), "go_only", "go_stop")
dat$component <- factor(dat$component)
des <- design(data = dat,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
contrasts = list(lM = ADmat),
constants = c("p1_groupstop:lMd" = 0,
"t0_groupchange" = log(0),
"t0_groupstop" = log(0)))
emc <- make_emc(dat, des, type = "single")
emc <- fit(emc, fileName = "stop_change_3rd.RData")
