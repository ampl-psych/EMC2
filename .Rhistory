plot(pri, selection = "correlation")
credint(samples_LNR, selection = "mu", map = list(~ E*S))
traceback()
credint(samples_LNR, selection = "mu", map = "E")
credint(samples_LNR)
credint(samples_LNR, selection = "mu", map = "lM")
debug(wrap_mapped_pars)
devtools::load_all()
debug(mapper_wrapper)
credint(samples_LNR, selection = "mu", map = list(~ E*S))
map
cur_col
i
data[,i]
data
head(data)
table(data$trials)
S
idx
devtools::load_all()
credint(samples_LNR, selection = "mu", map = list(~ E*S))
devtools::load_all()
credint(samples_LNR, selection = "mu", map = list(~ E*lM))
devtools::load_all()
debug(mapper_wrapper)
credint(samples_LNR, selection = "mu", map = list(~ E*lM))
devtools::load_all()
devtools::load_all()
devtools::load_all()
credint(samples_LNR, selection = "mu", map =TRUE) # list(~ E*lM))
devtools::load_all()
debug(mapper_wrapper)
credint(samples_LNR, selection = "mu", map = list(~ E*lM))
S
model.matrix(map[[i]], data = data[idx,])
devtools::load_all()
credint(samples_LNR, selection = "mu", map = list(~ E*lM))
devtools::load_all()
credint(samples_LNR, selection = "mu", map = TRUE) #list(~ E*lM))
devtools::load_all()
credint(samples_LNR, selection = "mu", map = TRUE) #list(~ E*lM))
credint(samples_LNR, selection = "mu", map = c("E", "lM"))
credint(samples_LNR, selection = "mu", map = list(~ E*lM))
devtools::test()
testthat::snapshot_review('group')
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- as.numeric(forstmann$subjects) -mean(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
pri <- prior(subj_design, group_design = group_des)
emc <- make_emc(forstmann, subj_design, group_design = group_des, prior_list = pri, compress = F, n_chains = 1)
print(group_des)
summary(group_des)
credint(pri, map = FALSE)
credint(pri, selection = "beta")
devtools::test()
testthat::snapshot_review('plot_fit/')
testthat::snapshot_review('S3/')
testthat::snapshot_review('map')
testthat::snapshot_review('group')
testthat::snapshot_review('fMRI/')
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Set up fake events
events <- data.frame(
subjects = rep(1, 10),
run = rep(1, 10),
onset = seq(0, 90, by = 10),
condition = rep(c("A", "B"), 5),
rt = runif(10, 0.5, 1.5),
accuracy = sample(0:1, 10, replace = TRUE)
)
# Reshape events to long format
reshaped <- reshape_events(events,
event_types = c("condition", "accuracy", "rt"),
duration = list(condition = 0.5,
accuracy = 0.2,
rt = function(x) x$rt),
modulation = list(rt = 1))
# Set up fake timeseries
ts <- data.frame(
subjects = rep(1, 100),
run = rep(1, 100),
time = seq(0, 99),
ROI1 = rnorm(100)
)
# Convolve long events
design_matrices <-  convolve_design_matrix(
timeseries = ts,
events = reshaped,
covariates = c('accuracy', 'rt'),
factors = list(cond = c("condition_A", "condition_B")),
contrasts = list(cond = matrix(c(-1, 1)))
)
# High pass filter timeseries
ts <- high_pass_filter(ts)
# Design for sampling
des <- design_fmri(design_matrices)
plot(prior(des),map=TRUE)
debug(mapper_wrapper)
plot(prior(des),map=TRUE)
debug(do_map)
plot(prior(des),map=TRUE)
out
drawws
draws
rm(list = ls())
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
# Set up fake events
events <- data.frame(
subjects = rep(1, 10),
run = rep(1, 10),
onset = seq(0, 90, by = 10),
condition = rep(c("A", "B"), 5),
rt = runif(10, 0.5, 1.5),
accuracy = sample(0:1, 10, replace = TRUE)
)
# Reshape events to long format
reshaped <- reshape_events(events,
event_types = c("condition", "accuracy", "rt"),
duration = list(condition = 0.5,
accuracy = 0.2,
rt = function(x) x$rt),
modulation = list(rt = 1))
# Set up fake timeseries
ts <- data.frame(
subjects = rep(1, 100),
run = rep(1, 100),
time = seq(0, 99),
ROI1 = rnorm(100)
)
# Convolve long events
design_matrices <-  convolve_design_matrix(
timeseries = ts,
events = reshaped,
covariates = c('accuracy', 'rt'),
factors = list(cond = c("condition_A", "condition_B")),
contrasts = list(cond = matrix(c(-1, 1)))
)
# High pass filter timeseries
ts <- high_pass_filter(ts)
# Design for sampling
des <- design_fmri(design_matrices)
des$Ffactors$subjects
plot(prior(des, type = "single"),map=TRUE)
devtools::test()
rm(list = ls())
devtools::load_all()
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- as.numeric(forstmann$subjects) -mean(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
pri <- prior(subj_design, group_design = group_des)
emc <- make_emc(forstmann, subj_design, group_design = group_des, prior_list = pri, compress = F, n_chains = 1)
test_that("groups", {
expect_snapshot(print(group_des))
expect_snapshot(summary(group_des))
expect_snapshot(credint(pri, map = TRUE))
expect_snapshot(credint(pri, selection = "beta"))
expect_snapshot(init_chains(emc, particles = 10, cores_per_chain = 1)[[1]]$samples)
})
credint(pri, map = TRUE)
debug(do_map)
credint(pri, map = TRUE)
devtools::load_all()
credint(pri, map = TRUE)
plot(pri)
credint(pri, map = FALSE)
credint(pri, selection = "beta")
rm(list = ls())
devtools::load_all()
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- as.numeric(forstmann$subjects) -mean(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
pri <- prior(subj_design, group_design = group_des)
emc <- make_emc(forstmann, subj_design, group_design = group_des, prior_list = pri, compress = F, n_chains = 1)
debug(do_map)
credint(pri, map = TRUE)
cur_draws
apply(cur_draws, 1, hist)
forstmann$age
rm(list = ls())
devtools::load_all()
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- scale(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
forstmann$age
rm(list = ls())
devtools::load_all()
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- as.numeric(forstmann$subjects) -mean(as.numeric(forstmann$subjects))/
max(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
pri <- prior(subj_design, group_design = group_des)
emc <- make_emc(forstmann, subj_design, group_design = group_des, prior_list = pri, compress = F, n_chains = 1)
credint(pri, map = TRUE)
forstmann$age
hist(forstmann$age)
rm(list = ls())
devtools::load_all()
# Create subject-level design
subj_design <- design(data = forstmann, model = DDM,
formula = list(v ~ S, a ~ E, t0 ~ 1),
contrasts = list(S = contr.helmert))
# Add some age covariate and roughly demean
# Demeaning is important to ensure that the interpretation of the group-level intercept
# is the mean of the group (i.e., 'mu' still represents the group-level mean)
forstmann$age <- (as.numeric(forstmann$subjects) -mean(as.numeric(forstmann$subjects)))/
max(as.numeric(forstmann$subjects))
# Create fake group column
forstmann$group <- ifelse(forstmann$subjects %in%
unique(forstmann$subjects)[seq(1, 19, 2)], "A", "B")
# Create group-level design matrices
group_des <- group_design(
formula = list(v_S1 ~ age + group, a ~ age),
data = forstmann,
subject_design = subj_design,
contrasts = list(group = contr.bayes)
)
pri <- prior(subj_design, group_design = group_des)
emc <- make_emc(forstmann, subj_design, group_design = group_des, prior_list = pri, compress = F, n_chains = 1)
credint(pri, map = TRUE)
forstmann$age
hist(forstmann$age)
credint(pri, selection = "beta")
traceback()
debug(get_pars)
credint(pri, selection = "beta")
samples
selection
get_objects(type = type, sampler = emc, stage = stage,
selection = selection)
debug(get_objects)
get_objects(type = type, sampler = emc, stage = stage,
selection = selection)
debug(get_objects_standard)
sampler[[1]]$samples
devtools::load_all()
credint(pri, map = TRUE)
credint(pri, selection = "beta")
credint(samples_LNR)
credint(samples_LNR, map = TRUE)
credint(samples_LNR, map = TRUE, selection = "alpha")
credint(samples_LNR, map = "E", selection = "alpha")
?EMC2
help(package = "EMC2")
plot_pars(samples_LNR)
plot_pars(samples_LNR, map = TRUE)
hypothesis(samples_LNR, selection = "m")
hypothesis(samples_LNR, use_par = "m")
credint(samples_LNR)
hypothesis(samples_LNR, use_par = "m", selection = "mu")
debug(hypothesis)
hypothesis(samples_LNR, use_par = "m", selection = "mu")
psamples
psamples[[1]]$samples
samples
psamples
hypothesis(samples_LNR, use_par = "m", selection = "mu")
rownames(samples)
parameter
hypothesis(samples_LNR, parameter = "m", selection = "mu")
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, selection = "alpha")
plot_pars(samples_LNR, selection = "alpha", map = TRUE)
plot_pars(samples_LNR, selection = "mu", map = TRUE)
debug(do_map)
plot_pars(samples_LNR, selection = "mu", map = TRUE)
draws
draws
rm(list = ls())
devtools::load_all()
debug(plot_pars)
plot_pars(samples_LNR, selection = "mu", map = TRUE)
psamples
psamples[[1]]$samples$theta_mu
map
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, selection = "mu", map = TRUE)
devtools::test()
testthat::snapshot_review('S3/')
plot_pars(samples_LNR, all_subjects = T)
debug(plot_pars)
plot_pars(samples_LNR, all_subjects = T)
rm(list = ls())
devtools::load_all()
rm(list = ls())
devtools::load_all()
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, all_subjects = T)
rm(list = ls())
devtools::load_all()
debug(plot_pars)
plot_pars(samples_LNR, all_subjects = T)
fix_dots(dots, get_objects)
map
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, all_subjects = T, map = TRUE)
rm(list = ls())
devtools::load_all()
debug(plot_pars)
plot_pars(samples_LNR, all_subjects = T, map = TRUE)
fix_dots(dots, get_objects)
fix_dots(dots, get_objects, consider_dots = F)
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, all_subjects = T, map = TRUE)
rm(list = ls())
devtools::load_all()
plot_pars(samples_LNR, all_subjects = T, map = FALSE)
devtools::load_all()
devtools::test()
testthat::snapshot_review('group')
devtools::test()
devtools::test()
testthat::snapshot_review('Darwin/fMRI')
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
init_chains(custom_emc, cores_for_chains = 1, particles = 10)
debug(init_chains)
init_chains(custom_emc, cores_for_chains = 1, particles = 10)
debug(init)
rm(list = ls())
devtools::load_all()
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
expect_snapshot(init_chains(custom_emc, cores_for_chains = 1, particles = 10))
rm(list = ls())
devtools::load_all()
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
debug(get_startpoints)
expect_snapshot(init_chains(custom_emc, cores_for_chains = 1, particles = 10))
rm(list = ls())
devtools::load_all()
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
debug(get_startpoints_standard)
expect_snapshot(init_chains(custom_emc, cores_for_chains = 1, particles = 10))
group_designs
calculate_subject_means(group_designs, start_mu)
calculate_subject_means(group_designs = list(), start_mu)
fit(samples_LNR)
rm(list = ls())
devtools::load_all()
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
debug(get_startpoints_standard)
expect_snapshot(init_chains(custom_emc, cores_for_chains = 1, particles = 10))
n_pars
.rs.restartR()
rm(list = ls())
devtools::load_all()
# Simple normal likelihood, the first half of the parameters are the means,
# the second half the variances. We exp them to ensure positive variances
custom_ll <- function(pars, dadm, ...){
idx <- dadm$S == "left"
ll_left <- dnorm(dadm$rt[idx], pars[1], exp(pars[3]))
ll_right <- dnorm(dadm$rt[!idx], pars[2], exp(pars[4]))
return(sum(log(c(ll_left, ll_right))))
}
library(EMC2)
pars <- c("muL", "muR", "sdL", "sdR")
design <- design(model = custom_ll, custom_p_vector = pars)
# using nuisance = 3:4
custom_emc <- make_emc(get_data(samples_LNR), design, type = "standard", nuisance_non_hyper = 3:4)
RNGkind("L'Ecuyer-CMRG")
set.seed(123)
debug(get_startpoints_standard)
expect_snapshot(init_chains(custom_emc, cores_for_chains = 1, particles = 10))
pmwgs$par_names
