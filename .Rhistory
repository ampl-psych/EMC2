add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("C2L", "change2left") |>
add_pool("C2R", "change2right") |>
add_outcome("Left", first_of(inhibit("GO_LEFT", by = "STOP"),all_of("STOP", "C2L")),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("Right", first_of(inhibit("GO_RIGHT", by = "STOP"),all_of("STOP", "C2R")),
options = list(component = c("go_only", "go_stop"))
) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change2left", "change2right"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(univalent_stop_change)
group_lmfun <- function(data){
out <- rep("go_match", nrow(data))
# First stop accumulator
idx_stop <- data$accumulator == "stop"
out[idx_stop] <- "stop"
# mismatching go accumulator
idx_go_mm <- data$accumulator == "go_left" & data$S == "Right" |
data$accumulator == "go_right" & data$S == "Left"
out[idx_go_mm] <- "go_mismatch"
# matching change accumulator
idx_change_m <- data$accumulator == "change2left" & data$S == "Right" |
data$accumulator == "change2right" & data$S == "Left"
out[idx_change_m] <- "change_match"
# mismatching change accumulator
idx_change_mm <- data$accumulator == "change2left" & data$S == "Left" |
data$accumulator == "change2right" & data$S == "Right"
out[idx_change_mm] <- "change_mismatch"
return(factor(out))
}
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "Left" & (data$accumulator == "go_left" | data$accumulator == "change2right")] <- TRUE
out[data$S == "Right" & (data$accumulator == "go_right" | data$accumulator == "change2left")] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator %in% c("change2left", "change2right")
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$SSD
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
ADmat <- cbind(d = c(1/2, -1/2))
dat$cond <- ifelse(dat$SSD == 0, "GO", "STOP")
dat$cond <- factor(dat$cond)
dat$component <- ifelse(dat$SSD == 0, "go_only", "go_stop")
dat$component <- factor(dat$component)
# debug(group_lmfun)
des <- design(data = dat,
formula = list(p1 ~ 0 + gLM, p2 ~ 0 + gLM, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(gLM = group_lmfun, group = group_fun, onset = onset_fun),
constants = c("t0_groupchange" = log(0),
"t0_groupstop" = log(0)))
load("stop_change_8.RData")
pp <- predict(emc, n_cores = 10, n_post = 50)
plot_cdf(dat, pp, factors = c("S", "cond"))
rm(list = ls())
devtools::load_all()
load("~/Documents/2026/StopData/3B_stopchange/clean_data_stop_change_v1_pilot.Rdata")
library(AccumulatR)
data <- d
# Some inspection
table(data$R)
table(data$R)/nrow(data)
table(data$S)
head(data)
# Some data wrangling
data <- data[,c("s", "SS", "S", "R", "RT", "SSD")]
colnames(data)[c(1,5)] <- c("subjects", "rt")
head(data)
data <- data[data$subjects == unique(data$subjects)[1],]
data$SSD[data$SS == "GoTask"] <- 0
# Recode levels
data$S <- factor(data$S)
data$R <- factor(data$R)
data$subjects <- factor(data$subjects)
# Set up AccumulatR model
three_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal") |>
add_accumulator("change", "lognormal") |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("CHANGE", "change") |>
add_outcome("A", inhibit("GO_LEFT", by = "STOP"),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("B", inhibit("GO_RIGHT", by = "STOP"),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("X", all_of("CHANGE", "STOP"),
options = list(component = "go_stop")) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(three_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "A"  & data$accumulator == "go_left"] <- TRUE
out[data$S == "B"  & data$accumulator == "go_right"] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator == "change"
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$SSD
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
data$component <- "go_only"
data$component[data$SS == "ChangeTask"] <- "go_stop"
data$component <- factor(data$component)
ADmat <- cbind(d = c(1/2, -1/2))
des <- design(data = data,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group/lM, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
constants = c("t0_groupchange" = log(0),
"t0_groupstop" = log(0),
"p1_groupchange:lMd" = 0,
"p1_groupstop:lMd" = 0,
"p2_groupchange:lMd" = 0,
"p2_groupstop:lMd" = 0),
contrasts = list(lM = ADmat))
dat
data
plot_cdf(data, pp, factors = c("cond", "S"), functions = list(cond = return(data$SS)))
rm(list = ls())
devtools::load_all()
load("~/Documents/2026/StopData/3B_stopchange/clean_data_stop_change_v1_pilot.Rdata")
library(AccumulatR)
data <- d
# Some inspection
table(data$R)
table(data$R)/nrow(data)
table(data$S)
head(data)
# Some data wrangling
data <- data[,c("s", "SS", "S", "R", "RT", "SSD")]
colnames(data)[c(1,5)] <- c("subjects", "rt")
head(data)
data <- data[data$subjects == unique(data$subjects)[1],]
data$SSD[data$SS == "GoTask"] <- 0
# Recode levels
data$S <- factor(data$S)
data$R <- factor(data$R)
data$subjects <- factor(data$subjects)
# Set up AccumulatR model
three_stop_change <- race_spec() |>
add_accumulator("go_left", "lognormal") |>
add_accumulator("go_right", "lognormal") |>
add_accumulator("stop", "lognormal") |>
add_accumulator("change", "lognormal") |>
add_pool("GO_LEFT", "go_left") |>
add_pool("GO_RIGHT", "go_right") |>
add_pool("STOP", "stop") |>
add_pool("CHANGE", "change") |>
add_outcome("A", inhibit("GO_LEFT", by = "STOP"),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("B", inhibit("GO_RIGHT", by = "STOP"),
options = list(component = c("go_only", "go_stop"))) |>
add_outcome("X", all_of("CHANGE", "STOP"),
options = list(component = "go_stop")) |>
add_group("component:go_only", members = c("go_left", "go_right"),
attrs = list(component = "go_only")) |>
add_group("component:go_stop",
members = c("go_left", "go_right", "stop", "change"),
attrs = list(component = "go_stop")) |>
set_metadata(mixture = list(mode = "fixed",
components = list(component("go_only", weight = 0.75),
component("go_stop", weight = 0.25))
)) |>
finalize_model()
stop_change_EMC2 <- EMC2:::AccumulatR_model(three_stop_change)
lMfun <- function(data){
out <- rep(FALSE, nrow(data))
out[data$S == "A"  & data$accumulator == "go_left"] <- TRUE
out[data$S == "B"  & data$accumulator == "go_right"] <- TRUE
return(factor(out))
}
group_fun <- function(data){
group <- rep("go", nrow(data))
idx_change <- data$accumulator == "change"
idx_stop <- data$accumulator == "stop"
group[idx_change] <- "change"
group[idx_stop] <- "stop"
return(factor(group))
}
onset_fun <- function(data){
onset <- data$SSD
onset[data$accumulator %in% c("go_left", "go_right")] <- 0
return(onset)
}
data$component <- "go_only"
data$component[data$SS == "ChangeTask"] <- "go_stop"
data$component <- factor(data$component)
ADmat <- cbind(d = c(1/2, -1/2))
des <- design(data = data,
formula = list(p1 ~ 0 + group/lM, p2 ~ 0 + group/lM, t0 ~ 0 + group),
model = stop_change_EMC2,
functions = list(lM = lMfun, group = group_fun, onset = onset_fun),
constants = c("t0_groupchange" = log(0),
"t0_groupstop" = log(0),
"p1_groupchange:lMd" = 0,
"p1_groupstop:lMd" = 0,
"p2_groupchange:lMd" = 0,
"p2_groupstop:lMd" = 0),
contrasts = list(lM = ADmat))
load("stop_change_3B.RData")
devtools::load_all()
pp <- predict(emc, n_cores = 10)
plot_cdf(data, pp, factors = c("cond", "S"), functions = list(cond = return(data$SS)))
plot_cdf(data, pp, factors = c("cond", "S"), functions = list(cond = function(data)return(data$SS)))
plot_cdf(data, pp, factors = c("SS", "S"))
.rs.restartR()
devtools::install()
.rs.restartR()
load("~/Documents/2025/EMC2/stop_change_3B.RData")
rm(list = ls())
load("~/Documents/2025/EMC2/stop_change_3B.RData")
fit(emc)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/stop_change_3B.RData")
fit(emc)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/stop_change_3B.RData")
debug(EMC2:::calc_ll_manager)
fit(emc, cores_for_chains = 1)
save(proposals, dadm, constants, designs, model, p_types, file = "profile.RData")
load("~/Documents/2025/EMC2/profile.RData")
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
emc <- EMC2:::AccumulatR_check_contex(emc)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
load("~/Documents/2025/EMC2/stop_change_3B.RData")
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
emc[[1]]$model()
emc[[1]]$model()$spec
library(microbenchmark)
microbenchmark(lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
,times = 10)
lla
lls
save(lls, file = "pre_change.RData")
.rs.restartR()
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
microbenchmark(lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
,times = 10)
microbenchmark(lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
,times = 10)
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
.rs.restartR()
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
head(lls)
load("~/Documents/2025/EMC2/pre_change.RData")
head(lls)
.rs.restartR()
rm(list = ls())
library(EMC2)
load("~/Documents/2025/EMC2/profile.RData")
load("~/Documents/2025/EMC2/stop_change_3B.RData")
emc <- EMC2:::AccumulatR_check_context(emc)
dadm <- emc[[1]]$data[[1]]
constants <- attr(dadm, "constants")
context <- attr(dadm, "AccumulatR_context")
lls <- EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context)
head(lls)
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
system.time(EMC2:::calc_ll_AccR(proposals, dadm, constants = constants, designs = designs,
model$bound, model$transform, model$pre_transform, p_types = p_types, min_ll = log(1e-10),
model$trend, context))
rm(list = ls())
library(EMC2)
# Imagine this is group 1
s1 <- samples_LNR
# And this is group 2
s2 <- samples_LNR
rm(list = ls())
library(EMC2)
# Imagine this is group 1
s1 <- samples_LNR
p1 <- parameters(samples_LNR, use_par = "m")
# And this is group 2
s2 <- samples_LNR
p2 <- parameters(samples_LNR, use_par = "s")
rm(list = ls())
library(EMC2)
# Imagine this is group 1
s1 <- samples_LNR
p1 <- parameters(samples_LNR, use_par = "m")
# And this is group 2
s2 <- samples_LNR
p2 <- parameters(samples_LNR, use_par = "s")
samples <- p2 - p1
plot_difference <- function(samples, H0 = 0, plot = TRUE) {
# Calculate proportion larger than H0
prop_larger <- mean(samples > H0)
if (plot) {
# Plot density
d <- density(samples)
plot(d, main = "Density of Differences", xlab = "Difference", ylab = "Density")
# Add abline at H0
abline(v = H0, col = "red", lty = 2, lwd = 2)
}
return(prop_larger)
}
# Example usage (optional, based on the script context)
# result <- plot_difference(samples)
# print(result)
rm(list = ls())
library(EMC2)
# Imagine this is group 1
s1 <- samples_LNR
p1 <- parameters(samples_LNR, use_par = "m")
# And this is group 2
s2 <- samples_LNR
p2 <- parameters(samples_LNR, use_par = "s")
samples <- p2 - p1
plot_difference <- function(samples, H0 = 0, plot = TRUE) {
# Calculate proportion larger than H0
prop_larger <- mean(samples > H0)
if (plot) {
# Plot density
d <- density(samples)
plot(d, main = "Density of Differences", xlab = "Difference", ylab = "Density")
# Add abline at H0
abline(v = H0, col = "red", lty = 2, lwd = 2)
}
return(prop_larger)
}
# Example usage
result <- plot_difference(samples)
rm(list = ls())
library(EMC2)
# Imagine this is group 1
s1 <- samples_LNR
p1 <- parameters(samples_LNR, use_par = "m")
# And this is group 2
s2 <- samples_LNR
p2 <- parameters(samples_LNR, use_par = "s")
samples <- p2 - p1
plot_difference <- function(samples, H0 = 0, plot = TRUE) {
# Calculate proportion larger than H0
prop_larger <- mean(samples > H0)
if (plot) {
# Plot density
d <- density(samples)
plot(d, main = "Density of Differences", xlab = "Difference", ylab = "Density")
# Add abline at H0
abline(v = H0, col = "red", lty = 2, lwd = 2)
}
return(prop_larger)
}
# Example usage
plot_difference(samples)
