names(out) <- comps
out
}
split_list_to_dfs(res)
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 5)
plot_sbc_hist(SBC_DDM_single)
plot_sbc_ecdf(SBC_DDM_single)
debug(plot_sbc_hist)
plot_sbc_hist(SBC_DDM_single)
ranks$rank
ranks
n_sample
nrow(ranks[[1]])
load("~/Documents/2025/EMC2/vignettes/SBC_data/SBC_RDM.RData")
SBC_RDM$rank
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 5)
plot_sbc_hist(SBC_DDM_single)
SBC_DDM_single$rank
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 5)
plot_sbc_hist(SBC_DDM_single)
stats <- SBC_DDM_single
stats
NULL$NULL
a <- NULL
a$test
devtools::load_all()
plot_sbc_hist(SBC_DDM_single)
devtools::load_all()
debug(plot_sbc_hist)
plot_sbc_hist(SBC_DDM_single)
stats
ranks
ranks$rank
devtools::load_all()
debug(calc_sbc_stats)
plot_sbc_hist(SBC_DDM_single)
devtools::load_all()
debug(calc_sbc_stats)
plot_sbc_hist(SBC_DDM_single)
out
devtools::load_all()
plot_sbc_hist(SBC_DDM_single)
SBC_DDM_single
devtools::load_all()
plot_sbc_hist(SBC_DDM_single)
devtools::load_all()
plot_sbc_hist(SBC_DDM_single)
plot_sbc_ecdf(SBC_DDM_single)
load("~/Documents/2025/EMC2/vignettes/SBC_data/SBC_RDM.RData")
plot_sbc_ecdf(SBC_RDM)
load("~/Documents/2025/EMC2/vignettes/SBC_data/SBC_LBA_single.RData")
plot_sbc_ecdf(SBC_LBA_single)
devtools::document()
devtools::load_all()
devtools::check()
debug(run_SBC_subject)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 5, functions = list(rt = pollute_rts))
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(rt, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
delta_monitor = 60, delta_quant = 125, delta_bin = 60){
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(run_SBC_subject)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 5, functions = list(rt = pollute_rts))
debug(run_SBC_subject)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, functions = list(rt = pollute_rts))
?make_data
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(rt, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
delta_monitor = 60, delta_quant = 125, delta_bin = 60){
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(run_SBC_subject)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, functions = list(rt = pollute_rts))
rm(list = ls())
devtools::load_all()
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(rt, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 60, delta_quant = 125, delta_bin = 60){
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(run_SBC_subject)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, functions = list(rt = pollute_rts))
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(rt, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 60, delta_quant = 125, delta_bin = 60){
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(pollute_rts)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, functions = list(rt = pollute_rts))
rt
devtools::load_all()
devtools::check()
devtools::document()
devtools::load_all()
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(rt, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 1/60, delta_quant = 1/125, delta_bin = 1/60){
rt <- data$rt
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(pollute_rts)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, post_functions = list(rt = pollute_rts))
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(data, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 1/60, delta_quant = 1/125, delta_bin = 1/60){
rt <- data$rt
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
debug(pollute_rts)
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, post_functions = list(rt = pollute_rts))
rt
data$rt
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(data, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 1/60, delta_quant = 1/125, delta_bin = 1/60){
rt <- data$rt
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50,
fileName = "SBC_DDM.RData", cores_per_chain = 1, post_functions = list(rt = pollute_rts))
devtools::load_all()
devtools::load_all()
plot_sbc_hist(SBC_DDM_single)
plot_sbc_ecdf(SBC_DDM_single)
rm(list = ls())
devtools::load_all()
design_DDM <- design(factors=list(subjects=1,S=c("left", "right")),
Rlevels = c("left", "right"),
formula =list(v~1,a~1, t0~1, s~1, Z~1, sv~1),
constants=c(s=log(1)),
model = DDM)
pollute_rts <- function(data, add_monitor_noise = TRUE, add_quantization = TRUE, add_fake_digits = TRUE,
use_ceiling = TRUE, delta_monitor = 1/60, delta_quant = 1/125, delta_bin = 1/60){
rt <- data$rt
n_trials <- length(rt)
# Step 1: Add monitor noise
if (add_monitor_noise) {
monitor_error <- runif(n_trials, min = 0, max = delta_monitor)
rt <- rt + monitor_error
}
# Step 2: Apply quantization, this does not allow both clock and keyboard quantization
if (add_quantization) {
if (use_ceiling) {
rt <- delta_quant * ceiling(rt / delta_quant)  # Keyboard quantization
} else {
rt <- delta_quant * floor(rt / delta_quant)    # Clock quantization
}
}
# Step 3: Add fake-digit noise
if (add_fake_digits) {
fake_digit_noise <- runif(n_trials, min = 0, max = delta_bin)
rt <- rt + fake_digit_noise
}
return(rt)
}
prior_DDM <- prior(design_DDM, type = "single",
pmean = c(1, log(.8), log(.3), qnorm(.5), log(.1)),
psd = c(.15, .15, .1, .05, .15))
SBC_DDM_single <- run_sbc(design_DDM, prior_DDM, replicates = 5, trials = 50, rt_resolution = 1/60, compress = TRUE,
fileName = "SBC_DDM.RData", cores_per_chain = 1, post_functions = list(rt = pollute_rts))
devtools::document()
devtools::load_all()
devtools::check()
devtools::test()
testthat::snapshot_review('Darwin/variant_funs')
testthat::snapshot_review('trend')
testthat::snapshot_accept('model_functions')
testthat::snapshot_accept('model_functions')
testthat::snapshot_review('profile/')
devtools::test()
testthat::snapshot_accept('stopS')
testthat::snapshot_accept('Darwin/fit')
testthat::snapshot_accept('make_emc')
devtools::test()
testthat::snapshot_accept('new_models')
testthat::snapshot_accept('group')
testthat::snapshot_accept('joint')
devtools::test()
devtools::check()
devtools::load_all()
devtools::load_all()
plot_cdf(forstmann)
plot_cdf(get_data(samples_LNR))
plot_cdf(samples_LNR, to_plot = "data")
?plot_cdf
devtools::install()
rm(list = ls())
library(EMC2)
Rcpp::sourceCpp("userfun_example.cpp")
Rcpp::sourceCpp("../userfun_example.cpp")
ptr <- EMC2_make_my_sum_ptr()          # produced by the macro
ptr <- EMC2:::EMC2_make_my_sum_ptr()          # produced by the macro
Rcpp::sourceCpp("../userfun_example.cpp")
Rcpp::compileAttributes()
devtools::load_all()
remove.packages("EMC2")
.rs.restartR()
devtools::install()
rm(list = ls())
library(EMC2)
Rcpp::sourceCpp("../userfun_example.cpp")
ptr <- EMC2:::EMC2_make_my_sum_ptr()          # produced by the macro
ptr <- EMC2_make_my_sum_ptr()          # produced by the macro
devtools::load_all()
Rcpp::compileAttributes()
remove.packages("EMC2")
devtools::install()
rm(list = ls())
library(EMC2)
Rcpp::sourceCpp("../userfun_example.cpp")
ptr <- EMC2_make_my_sum_ptr()          # produced by the macro
.rs.restartR()
rm(list = ls())
library(EMC2)
Rcpp::sourceCpp("../userfun_example.cpp")
ptr <- EMC2_make_my_sum_ptr()          # produced by the macro
remove.packages("EMC2")
.rs.restartR()
devtools::install()
.rs.restartR()
rm(list = ls())
library(EMC2)
Rcpp::sourceCpp("../userfun_example.cpp")
ptr <- EMC2_make_my_sum_ptr()          # produced by the macro
EMC2::apply_and_square(2, 3, ptr)      # (2+3)^2 = 25
EMC2:::apply_and_square(2, 3, ptr)      # (2+3)^2 = 25
devtools::load_all()
Rcpp::compileAttributes()
devtools::load_all()
devtools::load_all()
remove.packages("EMC2")
Rcpp::compileAttributes()
devtools::install()
.rs.restartR()
remove.packages("EMC2")
.rs.restartR()
devtools::install()
.rs.restartR()
devtools::load_all()
rm(list = ls())
library(EMC2)
#Register the custom kernel with transforms: b has pnorm
ct <- register_trend(trend_parameters = c("a", "b"), file = "../userfun_example.cpp",
transforms = c(a = "identity", b = "pnorm"),
base = "add")
remove.packages("EMC2")
Rcpp::compileAttributes()
remove.packages("EMC2")
devtools::load_all()
devtools::install()
.rs.restartR()
rm(list = ls())
library(EMC2)
#Register the custom kernel with transforms: b has pnorm
ct <- register_trend(trend_parameters = c("a", "b"), file = "../userfun_example.cpp",
transforms = c(a = "identity", b = "pnorm"),
base = "add")
.rs.restartR()
rm(list = ls())
library(EMC2)
#Register the custom kernel with transforms: b has pnorm
ct <- register_trend(trend_parameters = c("a", "b"), file = "../userfun_example.cpp",
transforms = c(a = "identity", b = "pnorm"),
base = "add")
#Register the custom kernel with transforms: b has pnorm
debug(register_trend)
ct <- register_trend(trend_parameters = c("a", "b"), file = "../userfun_example.cpp",
transforms = c(a = "identity", b = "pnorm"),
base = "add")
ct <- register_trend(trend_parameters = c("a", "b"), file = "../userfun_example.cpp",
transforms = c(a = "identity", b = "pnorm"),
base = "add")
file
sourceCpp("../userfun_example.cpp")
Rcpp::sourceCpp("../userfun_example.cpp")
