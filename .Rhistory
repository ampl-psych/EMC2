RM=c(0,0,0,0,0,1)) # right match
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1), # left match
RM=c(0,0,0,0,0,1)) # right match
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
cSlR
cbind(1, cSlR)
p_vector <- sampled_pars(designSSexG)
p_vector
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
# proportion of each SSD stopped triggered
tapply(dat$R %in% c("left","right"),dat$SSD,mean,na.rm=TRUE)
# RT as expected
round(tapply(dat$rt, cbind.data.frame(S=dat$S,R=dat$R,
SS=is.finite(dat$SSD)),mean,na.rm=TRUE),3)
# Check likelihood
profile_plot(dat,designSSexG,p_vector,n_cores=9,layout=c(2,5), use_c = TRUE)
r
r
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = make_ssd))
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = make_ssd))
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000,
functions = list(SSD = make_ssd()))
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
table(dat$R)
head(dat)
table(dat$R[!is.infinite(dat$SSD)])
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.38,.5,.67),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
tab <- table(dat$R[!is.infinite(dat$SSD)])
tab[1]/(sum(tab[2:3]))
tab[1]/(sum(tab))
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.3,.4,.5),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
tab <- table(dat$R[!is.infinite(dat$SSD)])
tab[1]/(sum(tab))
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.2,.3,.4),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
tab <- table(dat$R[!is.infinite(dat$SSD)])
tab[1]/(sum(tab))
rm(list = ls())
devtools::load_all("~/Documents/2025/EMC2/")
# library(EMC2)
# 1 go / 2 ST (e.g., bimanual go and selective unimanual) ----
lIfun <- \(d) factor(rep(c(2,1,1),times=nrow(d)/3),levels=1:2)
mySSD_function <- function(d) EMC2:::SSD_function(d,
SSD=c(.2,.3,.35),p=rep(.25/3,3))
# As above, have to preserve levels of matchfun when SSD not present
matchfun <- function(d){
if (is.null(d$SSD)){
factor(rep(TRUE,nrow(d)),levels=c("FALSE","TRUE"))
}else{
factor((is.infinite(d$SSD) & d$lR=="both") | (!is.infinite(d$SSD) & d$lR=="right"))
}
}
# Stimulus conditions:
# "goL"  => double press unless a stop signal = left press
# "goR" => double press unless a stop signal = right press
# Setup contrast so same rate for both when either go-left stop signal or
# go right stop-signal, as seems plausible.
# A limitation is that there are always left and right ST accumulators, so we
# cannot take the accumulator that should not be trigger entirely out of the
# race (e.g., the right accumulator in goL) so instead we effectively take it
# out of the race (NT = not triggered) by making it very slow as a constant.
SlR <- function(d) factor(paste0(d$S,d$lR))
cSlR <- cbind(B= c(1,0,0,1,0,0), # both
NT=c(0,0,1,0,1,0), # not triggered
UM=c(0,1,0,0,0,1)) # unimanual
designSSexG <- design(model=SSEXG,
factors=list(subjects=1,S=c("goL","goR")),
Rlevels=c("both","left","right"),
matchfun=matchfun,contrasts=list(SlR=cSlR),
functions=list(lI=lIfun,SlR=SlR),
covariates = "SSD",
constants=c(mu=0,mu_SlRNT=log(1e6)),
formula=list(mu~SlR,sigma~1,tau~1,muS~1,sigmaS~1,tauS~1, gf~1,tf~1)
)
p_vector <- sampled_pars(designSSexG)
# Make ST faster than both, and ST left faster than ST right
p_vector[1:length(p_vector)] <- c(log(.425), log(.4), log(.05),
log(0.1), log(0.2),log(0.025),log(0.05), qnorm(.05),qnorm(.05))
mapped_pars(designSSexG,p_vector)
set.seed(123)
dat <- make_data(p_vector, designSSexG, n_trials = 10000, functions = list(SSD = mySSD_function))
tab <- table(dat$R[!is.infinite(dat$SSD)])
tab[1]/(sum(tab))
# proportion of each SSD stopped triggered
tapply(dat$R %in% c("left","right"),dat$SSD,mean,na.rm=TRUE)
# RT as expected
round(tapply(dat$rt, cbind.data.frame(S=dat$S,R=dat$R,
SS=is.finite(dat$SSD)),mean,na.rm=TRUE),3)
# Check likelihood
profile_plot(dat,designSSexG,p_vector,n_cores=9,layout=c(2,5), use_c = TRUE)
devtools::load_all()
devtools::test()
