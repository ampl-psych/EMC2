---
title: "Trends"
description: "A guide to trends in EMC2"
author: "Niek Stevenson"
output: rmarkdown::html_document
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{"Trends"}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE}
rm(list = ls())
library(EMC2)
```

## Introduction

Trends in EMC2 allow you to model how parameters change as a function of covariates or other parameters. They provide a flexible way to capture systematic changes in model parameters across conditions or over time. This vignette shows:

- How to specify trends with kernels and bases
- How to attach trends to models via `design()` and run via `make_emc()` and `fit()`
- How to control when a trend is applied (premap, pretransform, posttransform)
- How to share trend parameters
- How to use other parameters as trend inputs (`par_input`)
- How to register and use a custom C++ trend kernel

## Trend Composition

A trend is composed of a kernel and a base. The kernel maps inputs to a per‑trial value `k`; the base then maps `k` into the parameter scale. Use `trend_help()` to list kernels and bases. The timing of when a trend is applied is controlled by `phase` (see [Phases](#phases) below).

```{r}
trend_help()
```

## Quick Start: From trend to model

Below is a minimal pipeline using an existing dataset (`samples_LNR`) to demonstrate where a trend fits in. We create a trend, attach it in the design, and show how it plugs into `make_emc()` and `fit()` (calls not evaluated here).

```{r}
# Example trend: log-mean increases linearly with trial
trend_quick <- make_trend(
  par_names = "m",
  cov_names = "trial_nr",
  kernels   = "lin_incr",
  bases     = "lin",
  phase     = "pretransform"
)

data <- get_data(samples_LNR)
# This does not take subject id into account
data$trial_nr <- 1:nrow(data)

# Build a design with the trend
design_trend <- design(
  data     = data,
  trend    = trend_quick,
  matchfun = function(d) d$S == d$lR,
  formula  = list(m ~ lM, s ~ 1, t0 ~ 1),
  contrasts = list(lM = matrix(c(-1/2, 1/2), ncol = 1, dimnames = list(NULL, "d"))),
  model    = LNR
)

# How you would run (not executed here)
# emc <- make_emc(data, design_trend, type = "single")
# fit <- fit(emc)
```

## Defining a Trend

A trend is created using the `make_trend()` function with the following main arguments:

- `par_names`: Which cognitive model parameters to apply the trend to
- `cov_names`: Which covariates to use for each trend
- `kernels`: Which kernel function to use for each trend
- `bases`: Optional base functions for each trend

Let's take the following example:

```{r}
trend_lin_decr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "lin_incr",
  bases = "lin"
)
```
This trend applies a linear increasing kernel to `v` using `trial` as input. This captures a hypothesis that the drift rate (`v`) increases over trials. To see how the trend is formulated use `trend_help()`.

```{r}
trend_help(kernel = "lin_incr")
```

The function tells us how the kernel maps the covariate to the kernel `k`. In this case the kernel `k` is just the covariate `c`. The kernel is then used in the base function. The `trend_help()` function also shows us the available base functions for this kernel. In this case we will use the `lin` base function. To see how this base function is formulated we can use the `trend_help()` function again.

```{r}
trend_help(base = "lin")
```
Together these specify how the trend affects the model parameter. With base `lin`, the mapping is `v <- v + B0 * k`, where `B0` is the base parameter and `k` comes from the kernel (here `k = c`, the covariate). Although this separation may seem verbose for simple cases, it makes more complex specifications clear and composable.

EMC2 automatically creates parameter names for the trend, which can be accessed using the `get_trend_pnames()` function.

```{r}
get_trend_pnames(trend_lin_decr)
```
These parameter names are now included in the parameter types of the model. 

## Available Kernel Types

EMC2 provides several kernel functions for modeling how cognitive model parameters change as a function of covariates.

### Linear Trends
```{r}
# Linear decreasing trend
trend_lin_decr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "lin_decr"
)

# Linear increasing trend
trend_lin_incr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "lin_incr"
)
```

Linear trends model straight‑line relationships between parameters and covariates. They are often a good starting point. You could encode linear effects via `design()` covariates, but bundling them into a trend enables shared control via bases and phases and keeps specifications local to parameters.

### Exponential Trends
```{r}
# Exponential decreasing trend
trend_exp_decr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "exp_decr"
)

# Exponential increasing trend
trend_exp_incr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "exp_incr"
)
```

Exponential trends are useful for rapid initial changes that level off. `exp_decr` captures decay; `exp_incr` captures learning.

### Power Trends
```{r}
# Power decreasing trend
trend_pow_decr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "pow_decr"
)

# Power increasing trend
trend_pow_incr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "pow_incr"
)
```

Power trends provide another way to model non‑linear relationships, often used for practice effects.

### Polynomial Trends
```{r}
# Quadratic trend
trend_poly2 <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "poly2"
)

# Cubic trend
trend_poly3 <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "poly3"
)

# Quartic trend
trend_poly4 <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "poly4"
)
```

Polynomial trends allow for complex relationships, including multiple turning points. Use higher orders cautiously to avoid overfitting.

### Learning Rule Trends
```{r}
# Standard delta learning rule
trend_delta <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "delta"
)

# Dual learning rate delta rule
trend_delta2 <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "delta2kernel"
)
```

Delta rules are useful for learning processes. The standard delta rule updates based on prediction error. The dual‑rate rule uses fast and slow learning rates, switching between them based on discrepancies.

Each kernel has supported bases. You can leave bases to defaults or set them explicitly. Changing bases can reflect different interpretations of how `k` enters the parameter:

 ```{r}
trend_exp_incr <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels = "exp_incr",
  bases =  "exp_lin"
)
 ```

For example with base `lin`: `v <- v + B0 * k`. With base `exp_lin`: `v <- exp(v) + exp(B0) * k`. The latter can be useful when the parameter operates on a multiplicative or positively constrained scale.


## Multiple Trends 

Some models have multiple parameters that are affected by the same covariate. In this case, we can specify multiple trends for the same covariate. Note that with the kernels argument, we can specify different kernels for each parameter.
```{r}
# Applying different trends to multiple parameters
trend_multi <- make_trend(
  par_names = c("v", "t0"),
  cov_names = c("trial"),
  kernels = c("exp_incr", "poly2")
)
```

Alternatively, different parameters may be affected by different covariates:

```{r}
# Specifying different covariates for each trend
trend_multi <- make_trend(
  par_names = c("v", "t0"),
  cov_names = c("trial", "block"),
  kernels = c("exp_incr", "poly2")
)
```

Lastly, a single parameter may be affected by multiple covariates:
```{r}
# Specifying multiple covariates for a trend
trend_multi <- make_trend(
  par_names = c("v", "t0"),
  cov_names = list(c("trial", "block"), "block"),
  kernels = c("exp_incr", "poly2")
)
```

At the time of writing, different kernels per‑covariate for the same parameter are not yet supported.

### Sharing Parameters
Sometimes multiple trend entries should use the same parameter(s). For example, share a base parameter across different target parameters:
```{r}
# Sharing parameters between trends
trend_shared <- make_trend(
  par_names = c("v", "a"),
  cov_names = "trial",
  kernels = c("exp_incr", "exp_incr"),
  shared = list(intercept = list("v.B0", "a.B0"))
)
```

This shares `B0` between `v` and `a` trends. Instead of two `B0` parameters, there is one named `intercept`. Use `get_trend_pnames()` to inspect the generated names:

```{r}
get_trend_pnames(trend_shared)
```

We can also specify multiple shared parameters, for example `shared = list(intercept = list("v.B0", "a.B0"), slope = list("v.d_ei", "a.d_ei"))`. 

## Phases

Control when a trend is applied via the `phase` argument:

- `premap`: before parameter mapping (i.e., modifies raw parameter vectors)
- `pretransform`: after mapping but before transforms
- `posttransform`: after transforms

```{r}
# Pre-mapping trend
trend_premap <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels   = "exp_incr",
  phase     = "premap"
)

# Pre-transform trend
trend_pretrans <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels   = "exp_incr",
  phase     = "pretransform"
)

# Post-transform trend
trend_posttrans <- make_trend(
  par_names = "v",
  cov_names = "trial",
  kernels   = "exp_incr",
  phase     = "posttransform"
)
```

Phases change how trends interact with mapping and transformations. For example, a `premap` trend can feed transformed outputs into parameter mapping, while `posttransform` trends act on the final, transformed parameter scale.

## Parameter Inputs (`par_input`)

Trends can also depend on other parameters via `par_input`. For example, use `t0` as an input to a trend on `m`:

```{r}
trend_par_input <- make_trend(
  par_names = "m",
  cov_names = NULL,
  kernels   = "lin_incr",
  par_input = list("t0"),
  phase     = "pretransform"
)
```
This example mirrors the tests: the input matrix provided to the kernel will contain the covariate columns (none here) followed by the `par_input` columns (here `t0`).

## Custom C++ Trends

You can register your own C++ kernel function. The function takes per‑trial kernel parameters `trend_pars` (base params excluded) and an input matrix, and returns a vector of outputs. To keep this vignette fast and portable, we show the code and how to register it but do not actually compile or run it here.

```{r, eval = FALSE}
library(EMC2)

# Write a custom kernel to a separate file
tf <- tempfile(fileext = ".cpp")
writeLines(c(
  "// [[Rcpp::depends(EMC2)]]",
  "#include <Rcpp.h>",
  "#include \"EMC2/userfun.hpp\"",
  "",
  "// Example: two params (a, b) and two inputs (covariate1, t0)",
  "Rcpp::NumericVector custom_kernel(Rcpp::NumericMatrix trend_pars, Rcpp::NumericMatrix input) {",
  "  int n = input.nrow();",
  "  Rcpp::NumericVector out(n, 0.0);",
  "  for (int i = 0; i < n; ++i) {",
  "    double a = (trend_pars.ncol() > 0) ? trend_pars(i, 0) : 0.0;",
  "    double b = (trend_pars.ncol() > 1) ? trend_pars(i, 1) : 0.0;",
  "    double in1 = input(i, 0);  // covariate1",
  "    double in2 = input(i, 1);  // t0",
  "    if ((i % 2) == 0) out[i] = (Rcpp::NumericVector::is_na(in1) ? 0.0 : in1) + a;",
  "    else             out[i] = (Rcpp::NumericVector::is_na(in2) ? 0.0 : in2) * b;",
  "  }",
  "  return out;",
  "}",
  "",
  "// Export pointer maker for registration",
  "// [[Rcpp::export]]",
  "SEXP EMC2_make_custom_trend_ptr();",
  "EMC2_MAKE_PTR(custom_kernel)"
), tf)

# Register with parameter names, transforms, and a default base
ct <- register_trend(
  trend_parameters = c("a", "b"),
  file = tf,
  transforms = c(a = "identity", b = "pnorm"),
  base = "add"
)

# Use in a trend (note par_input to add t0 as an input column)
trend_custom <- make_trend(
  par_names  = "m",
  cov_names  = "covariate1",
  kernels    = "custom",
  par_input  = list("t0"),
  phase      = "pretransform",
  bases      = NULL,         # uses ct$base (here: add)
  custom_trend = ct
)
```

Interpretation: the base controls how the custom kernel’s output enters the parameter (e.g., `add` means additive). The `transforms` declared in `register_trend()` are attached to the model so custom kernel parameters can be estimated under appropriate constraints.

## Tips for Choosing Trends

1. Start simple: Begin with linear trends before moving to more complex options
2. Match theory: Choose trends that align with theoretical expectations
3. Consider interpretability: Simpler trends are often easier to interpret
4. Watch for overfitting: More complex trends (like high-order polynomials) may overfit
5. Use shared parameters when you expect related processes
6. Choose `phase` based on how the trend should interact with mapping and transformations

## Interpreting Bases and Transforms

- `lin`: additive on the parameter scale (`θ <- θ + B0 * k`)
- `exp_lin`: additive on an exponentialized parameter (`θ <- exp(θ) + exp(B0) * k`)
- `centered`: centers `k` at 0.5 before scaling (`θ <- θ + B0*(k - 0.5)`)
- `add`: parameter is `θ <- θ + k` (no base parameter)
- `identity`: parameter is `θ <- k` (no base parameter)

Trend parameters can have default transforms (from `trend_help()`), and custom kernels can declare their own transforms via `register_trend()`. These transforms feed into the model’s transform pipeline, ensuring parameters respect intended bounds.
